import copy

class SigmaYamlConverter:

    def __init__(self, condition_data):

        self.condition_data = condition_data
        self.condition_list = self.convert_to_sigma_rule(self.condition_data)
        self.final_list : list[dict[str, list]|dict[str, dict]] = []
        self.logical_operators: list[str] = []
        self.detections = {}

        self.process_dict(self.condition_list)
        self.iterate_final_list()
        self.generate_sigma_rule()

    def iterate_final_list(self):
        
        condition_handler = SigmaConditionHandler()
        
        for condition in self.final_list:
            condition_handler.pass_condition(condition)

        self.detections = condition_handler.detection
            
    def process_dict(self, element, key=None):
        """
        Recursively processes a nested data structure (dicts, lists, dictionaries representing base values).
        When encountering a list of dictionaries representing base values (each dictionary containing 'term',
        'operator', and 'value' keys), it prints the list as a whole. Dictionaries and other types of lists are
        processed recursively as before.

        :param element: The current element to process, which can be a dictionary, list, or base value dictionary.
        :param key: The key associated with the current element, if any.
        """
        if isinstance(element, dict):
            # Process each key-value pair in the dictionary
            if element.get("term") is not None:
                #print(key, element)
                self.final_list.append({key : element})
            else:
                for sub_key, value in element.items():
                    self.process_dict(value, sub_key)  # Recurse with the value and pass the current key
        elif isinstance(element, list):
            # Check if this is a base list: a list where all items are dictionaries with 'term', 'operator', 'value'
            if all(isinstance(item, dict) and {'term', 'operator', 'value'}.issubset(item) for item in element):
                # If it's a base list, print the entire list with its associated key
                #print(f"{key} {element}")
                self.final_list.append({key : element})
            else:
                # If it's not a base list, recurse into its elements
                for item in element:
                    self.process_dict(item, key)
        # No specific handling for base value dictionaries here, as they're part of the base list handling
                
    def convert_to_sigma_rule(self, condition):

        if condition.get("type") == 'and':
            conditions = {"and" : [self.convert_to_sigma_rule(definition) for definition in condition['definitions']]}
            return conditions
        elif condition.get("type") == 'or':
            conditions = {"or" : [self.convert_to_sigma_rule(definition) for definition in condition['definitions']]}
            return conditions
        elif condition.get("type") == 'not':
            conditions = {"not" : [self.convert_to_sigma_rule(condition['definitions'][0])]}
            return conditions
        else:
            return condition

    def generate_sigma_rule(self):
        self.sigma_rule = {
            "title": "Generated Sigma Rule",
            "status": "experimental",
            "description": "Auto-generated Sigma rule from structured data",
            "author": "Generated by script",
            "logsource": {
                "category": "temp",
                "product": "temp"
            },
            "detection": {
                "condition": "temp"
            },
        }

        self.sigma_rule["detection"] = self.detections

        temp = []

        for i in self.sigma_rule["detection"]:
            if i != "condition":
                temp.append(i)
        self.sigma_rule["detection"]["condition"] = temp

    
class SigmaConditionHandler:

    def __init__(self):
        self.stack : list[dict[str, list]] = []
        self.keys = []
        self.buffer = []
        self.detection = {}

    
    def pass_condition(self, condition: dict[str,dict|str,list]):
        """Take incoming conditions and dispatch to appropriate methods."""
        key = list(condition.keys())[0]
        value = condition.get(key)
        if type(value) == dict:
            print(condition)
            self.__add_dict_condition(key, value)
        elif type(value) == list:
            self.__add_list_condition(key, value)

    def __add_dict_condition(self, key: str, condition: dict):
        """Handle adding dict conditions."""
        #first condition
        if len(self.buffer) == 0:
            self.buffer.append({"key" : key, "value" : [condition]})
        #follow on condition with same key
        elif self.buffer[0].get("key") == key:
            self.buffer[0]["value"].append(condition)
        #follow on condition with different key
        elif self.buffer[0].get("key") != key:
            if len(self.buffer) == 2 and self.buffer[1].get("key") == key:
                self.buffer[1]["value"].append(condition)
            else:
                self.buffer.append({"key" : key, "value" : [condition]})

    def __add_list_condition(self, key: str, condition_list: list):

        temp = {}
        #conditions in the buffer need to be added to previous detection
         
        self.__check_buffer(temp)
       
        #get processed result from list of conditions
        result = self.__handle_condition_list(key, condition_list)
        temp = self.__add_to_temp_detection(temp, result)
        
        #conditions still in the buffer need to be added to this detection
        self.__check_buffer(temp)
        
        #pass finalized detection
        self.detection[self.__get_detection_name()] = temp

    def __check_buffer(self, detection: dict[str|str, str|list]):
        """order: first=True, last=False"""
        #print(detection)
        pass

    def __empty_buffer(self):
        
        self.stack = self.buffer
        key = list(self.stack[0].keys())[0]
        key = self.stack[0].get(key)
        value = self.stack[0].get("value")
        #or dicts, should be its own detection
        if key == "or":
            if len(value) == 1:
                result = self.__handle_dict(value[0])
                return result
            elif len(value) > 1:
                result = self.__handle_condition_list(key, value)
                return result
        elif key == "and":
            if len(value) == 1:
                result = self.__handle_dict(value[0])
                return result
            elif len(value) > 1:
                result = self.__handle_condition_list(key, value)
                return result
            
    def __add_to_temp_detection(self, detection: dict, condition: dict|list):

        if type(condition) == dict:
            detection.update(condition)
        elif type(condition) == list:
            [detection.update(x) for x in condition]
        
        return detection

    def __add_to_previous_detection(self, detection):
        
        #detection needs to go into last_detection
        last_detection_name = list(self.detection.keys())[len(self.detection.keys())-1]
        last_detection = self.detection.get(last_detection_name)
        
        last_detection_keys = list(last_detection.keys())
        for key in detection.keys():
            if key in last_detection_keys:
                value = last_detection.get(key)
                if type(value) == list and type(detection.get(key)) == list:
                    value.extend(detection.get(key))
                elif type(value) == list and type(detection.get(key)) == str:
                    value.append(detection.get(key))
                elif type(value) == str and type(detection.get(key)) == list:
                    detection.get(key).append(value)
                    last_detection[key] = detection.get(key)
                elif type(value) == list and type(detection.get(key)) == list:
                    detection.get(key).extend(detection.get(key))
                            




    def __get_detection_name(self):

        return f"condition-{len(self.detection.values())}"
    
    def __handle_dict(self, condition: dict):
        
        term = condition["term"]
        operator = condition["operator"].lower()
        value = condition["value"]

        if operator != "eq":
            term = f"{term}|{operator}"
        else:
            term = term
        result = {term : value}
        return result
    
    def __handle_condition_list(self, key, condition_list: list[dict]):

        if key == "or":
            result = self.__handle_or_list(condition_list)
            return result
        
        elif key == "and":
            result = self.__handle_and_list(condition_list)
            return result
        elif key == "not":
            print("NOT LIST ENCOUNTERED")
            
    def __handle_or_list(self, condition_list: list[dict]):
        terms = list(set([x["term"] for x in condition_list]))
        operators = list(set([x["operator"].lower() for x in condition_list]))
        values = [x["value"] for x in condition_list]

        if len(terms) > 1 or len(operators) > 1:
            #print("OR: TERMS OR OPERATORS GREATER THAN 1 - DICT HANDLER")
            result_list = self.__or_terms_or_operators_over_1(condition_list)
            return result_list
        
        if operators[0] != "eq":
            terms = f"{terms[0]}|{operators[0]}"
        else:
            terms = terms[0]
        result = {terms : values}
        return result

    def __handle_and_list(self, condition_list: list[dict]):
        terms = list(set([x["term"] for x in condition_list]))
        operators = list(set([x["operator"].lower() for x in condition_list]))
        values = [x["value"] for x in condition_list]

        if len(terms) > 1 or len(operators) > 1:
            result_list = self.__and_terms_or_operators_over_1(condition_list)
            return result_list
        
        if operators[0] != "eq":
            terms = f"{terms[0]}|{operators[0]}"
        else:
            terms = terms[0]
        if len(values) > 1:
            result = {f"{terms}|all" : values}
        else:
            result = {f"{terms}" : values}
        return result

    def __and_terms_or_operators_over_1(self, condition_list: list[dict]):
        result_list = []
        temp = {}

        for entry in condition_list:
            if temp.get(f'{entry.get("term")}{entry.get("operator")}') == None:
                temp[f'{entry.get("term")}{entry.get("operator")}'] = [entry]
            elif f'{entry.get("term")}{entry.get("operator")}' is not None:
                temp[f'{entry.get("term")}{entry.get("operator")}'].append(entry)
        
        for key,condition_list in temp.items():
            terms = list(set([x["term"] for x in condition_list]))
            operators = list(set([x["operator"].lower() for x in condition_list]))
            values = [x["value"] for x in condition_list]
            if len(terms) > 1 or len(operators) > 1:
                print("AND: I DONT KNOW WHAT IM DOING")

            if operators[0] != "eq":
                terms = f"{terms[0]}|{operators[0]}"
            else:
                terms = terms[0]

            if len(values) > 1:
                result = {f"{terms}|all" : values}
            else:
                result = {f"{terms}" : values}
            result_list.append(result)
        return result_list
    
    def __or_terms_or_operators_over_1(self, condition_list):

        result_list = []
        temp = {}
        for entry in condition_list:
            if temp.get(f'{entry.get("term")}{entry.get("operator")}') == None:
                temp[f'{entry.get("term")}{entry.get("operator")}'] = [entry]
            elif f'{entry.get("term")}{entry.get("operator")}' is not None:
                temp[f'{entry.get("term")}{entry.get("operator")}'].append(entry)
        
        for key,condition_list in temp.items():
            terms = list(set([x["term"] for x in condition_list]))
            operators = list(set([x["operator"].lower() for x in condition_list]))
            values = [x["value"] for x in condition_list]
            if len(terms) > 1 or len(operators) > 1:
                print("OR: I DONT KNOW WHAT IM DOING")

            if operators[0] != "eq":
                terms = f"{terms[0]}|{operators[0]}"
            else:
                terms = terms[0]
            result = {f"{terms}" : values}
            result_list.append([result])
        return result_list
    
    def __clear(self):
        self.stack = []
        self.keys = []
        self.buffer.pop(0)
        


