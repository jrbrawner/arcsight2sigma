class YamlTest:

    def __init__(self, condition_data):
        self.condition_data = condition_data

        self.condition_list = self.convert_to_sigma_rule(self.condition_data)
        self.final_list = list[str|list]
        
        self.process_dict(self.condition_list)

    def process_dict(self, element, key=None):
        """
        Recursively processes a nested data structure (dicts, lists, strings) and prints the key
        for each value. When encountering a list or a string within a dictionary, the function
        prints the key associated with it.

        :param element: The current element to process, which can be a dictionary, list, or string.
        :param key: The key associated with the current element, if any.
        """
        if isinstance(element, dict):
            # Process each key-value pair in the dictionary
            for sub_key, value in element.items():
                self.process_dict(value, sub_key)  # Recurse with the value and pass the current key
        elif isinstance(element, list):
            # Process each item in the list. Lists don't have keys, so we pass along the parent key

            if all(isinstance(sub_element, str) for sub_element in element):
                # Process each string in the base list here (e.g., print it). For demonstration, we'll just print them.
                print(key, element)
            else:
                for item in element:
                    self.process_dict(item, key)
        elif isinstance(element, str):
            # Here, we process the string. If needed, print or handle the string and its key.
            # In this context, we'll print the associated key with the string.
            if key is not None:
                print(f"{key} {element}")



    def convert_to_sigma_rule(self, condition):

        if condition.get("type") == 'and':
            conditions = {"and" : [self.convert_to_sigma_rule(definition) for definition in condition['definitions']]}
            return conditions
        elif condition.get("type") == 'or':
            conditions = {"or" : [self.convert_to_sigma_rule(definition) for definition in condition['definitions']]}
            return conditions

        elif condition.get("type") == 'not':
            conditions = {"not" : [self.convert_to_sigma_rule(condition['definitions'][0])]}
            return conditions
        else:
            return f'{condition["term"]} {condition["operator"]} {condition["value"]}'
            #return condition

    def convert_to_sigma(self, data):
        sigma_rule = {
            "title": "Generated Sigma Rule",
            "status": "experimental",
            "description": "Auto-generated Sigma rule from structured data",
            "author": "Generated by script",
            "logsource": {
                "category": "process_creation",
                "product": "windows"
            },
            "detection": {
                "condition": "all of them"
            },
            "falsepositives": ["Unknown"],
            "level": "medium",
        }

        selections = {}
        for idx, definition in enumerate(data["definitions"], start=0):
            if definition.get("type") == "or":
                or_selections = []
                or_terms = []
                for or_def in definition["definitions"]:
                    or_selections.append(or_def["value"])
                    or_terms.append(or_def["term"])
                or_terms = list(set(or_terms))

                selections[f"selection{idx}"] = {f"{or_terms[0]}|contains" : or_selections}
            else:
                selections.setdefault("selections", []).append(f'{definition["term"]}|contains:{definition["value"]}')

        sigma_rule["detection"].update(selections)

        return sigma_rule